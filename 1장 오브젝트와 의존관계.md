# 1장 오브젝트와 의존관계

객체지향 프로그래밍이 가능한 언어 

- 스프링이 자바에서 가장 중요하게 가치를 두는 것

- DAO (Data Access Object)
    
    DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트
    

- 자바빈 (JavaBean)
    1. 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다
    2. 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 set으로 시작하는 수정자 메소드(setter)와 get으로 시작하는 접근자 메소드(getter)를 이용해 수정 또는 조회할 수 있다

 

### DAO의 분리

1. 관심사의 분리 (Separation of Concerns)
2. 커넥션 만들기의 추출
3. 리팩토링 : 외부의 동작 방식은 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술

### DAO의 확장

1. 클래스의 분리
2. 인터페이스의 확장
3. 관계설정 책임의 분리
4. 원칙과 패턴

### 제어의 역전 (IoC)

1. 오브젝트 팩토리
2. 제어권의 이전을 통한 제어관계 역전

### 스프링의 IoC

1. 오브젝트 팩토리를 이용한 스프링 IoC
    1. 애플리케이션 컨텍스트와 설정정보
    2. DaoFacotry를 사용하는 애플리케이션 컨텍스트
2. 애플리케이션 컨텍스트의 동작방식
    1. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다
    2. 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다
    3. 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다
3. 스프링 IoC의 용어 정리
    1. 빈 (Bean) : 스프링이 IoC 방식으로 관리하는 오브젝트 (스프링이 직접 생성과 제어를 담당하는 오브젝트)
    2. 빈 팩토리 (Bean Factory) : 빈을 등록, 생성, 조회 등을 담당하는 핵심 컨테이너
    3. 애플리케이션 컨텍스트 (Application Context) : 빈 팩토리를 확장한 IoC 컨테이너 (스프링이 제공하는 애플리케이션 지원 기능을 모두 포함)
    4. 설정정보 / 설정 메타정보 (Configuration metadata) : 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보
    5. 컨테이너 또는 IoC 컨테이너 (Container) : IoC 방식으로 빈을 관리하는 애플리케이션 컨텍스트 또는 빈 팩토리
    6. 스프링 프레임워크 (Spring Framwork) : IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능
    

### 싱글톤 레지스트리와 오브젝트 스코프

1. 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
    1. 스프링이 빈을 싱글톤으로 만드는 이유 : 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문
    2. 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다
    3. 디자인 패턴에서 싱글톤 패턴의 한계 : private 생성자를 갖고 있기 때문에 상속 불가능, 테스트하기 어려움, 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못함, 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못함
    4. 싱글톤 레지스트리 (Singleton Registry) : 스프링이 제공하는 싱글톤 형태의 오브젝트를 생성하고 관리하는 기능, 싱글톤 패턴과는 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 아무런 제약이 없음
2. 싱글톤과 오브젝트의 상태
3. 스프링 빈의 스코프
    1. 빈이 생성되고 , 존재하고, 적용되는 범위
    2. 스프링에서 만들어지는 대부분의 빈은 싱글톤 스코프를 가짐
    3. 프로토타입 스코프 : 프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어 줌
        
        

### 의존관계 주입 (DI)

1. 제어의 역전(IoC)와 의존관계 주입
2. 런타임 의존관계 설정
    1. 의존관계 : 누군가 누구에게 의존하는 관계 
    2. A가 B에 의존하고 있음 (B가 변하면 그것이 A에 영향을 미침)
        
        ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%A9%E1%84%87%E1%85%B3%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20c6742a4559a942f0806489b0471e72ab/Untitled.png)
        
    3. 의존관계에는 방향성이 있음 : B는 A의 변화에 영향을 받지 않음
    4. 의존관계 주입의 충족 요건
        1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다
        2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다
        3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다
3. 의존관계 검색과 주입
    1. 의존관계 검색 (Dependency Lookup) : 의존관계를 외부로부터의 주입이 아니라 스스로 검색을 이용함
    2. 자신이 필요로하는 의존 오브젝트를 능동적으로 찾음
    3. 검색하는 오브젝트는 자신이 스프링의 빈일필요가 없음
4. 의존관계 주입의 응용
    1. 기능 구현의 교환
    2. 부가기능 추가 (DB Connection Counting)
5. 메소드를 이용한 의존관계 주입
    1. 수정자(setter) 메소드를 이용한 주입
    2. 일반 메소드를 이용한 주입
6. XML을 이용한 설정
    1. 장점 : 다루기 쉬움, 쉽게 이해 가능, 컴파일과 같은 별도의 빌드 작업이 없음, 환경이 달라져도 빠르게 변경사항 반영 가능, 스키마나 DTD(Document Type Definition)를 통해 쉬운 포맷(정해진 형식) 확인 가능
    2. XML 설정
    3. XML을 이용하는 애플리케이션 컨텍스트
    4. DataSource 인터페이스로 변환
    

<aside>
💡 정리

- 책임이 다른 코드를 분리해서 두개의 클래스로 만듬 (관심사의 분리, 리팩토링)
- 바뀔수 있는 쪽의 클래스는 인터페이스화, 인터페이스를 통해서만 접근 가능 (전략 패턴)
- 책임 자체가 변경되는 경우 외에는 변화를 막아줌 (개방 폐쇄 원칙)
- 한쪽의 기능 변화가 다른 쪽의 변경을 요구 안함 (낮은 결합도)
- 자신의 책임과 관심사에만 순수하게 집중하게 되는 코드 (높은 응집도)
- 제어권을 오브젝트 팩토리를 만들어 넘겨줌 (IoC, 제어의 역전)
- 서버에서 사용되는 서비스 오브젝트로서의 장점을 살릴 수 있는 싱글톤 (싱글톤 레지스트리)
- 클래스와 인터페이스 사이의 느슨한 의존관계, 런타임 시에 실제 사용할 구체적 의존 오브젝트 (DI)
- 의존 오브젝트의 클래스 생성자 주입, 수정자 메소드 주입 (생성자, 수정자 주입)
- XML을 이용한 설정, 일반 값을 외부에서 설정해서 런타임 시에 주입 (XML 설정)
</aside>

> 스프링이란 ‘어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크’
>