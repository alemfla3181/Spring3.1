# 4장 예외

### 사라진 SQLException

1. 초난감 예외처리
    1. 예외 블랙홀 : 예외를 잡고 아무것도 하지 않는 경우
    2. 무의미하고 무책임한 throws
2. 예외의 종류와 특징
    1. Error
    2. Exception과 Checked Exception
    3. RuntimeException과 UnChecked Exception
3. 예외처리 방법
    1. 예외 복구
    2. 예외처리 회피
    3. 예외 전환
4. 예외처리 전략
    1. 런타임 예외의 보편화
    2. add() 메소드의 예외처리
    3. 애플리케이션 예외
5. SQLException은 어떻게 됐나?

### 예외 전환

1. JDBC의 한계
    1. 비표준 SQL
    2. 호환성 없는 SQLException의 DB 에러정보
2. DB 에러 코드 매핑을 통한 전환
3. DAO 인터페이스와 DataAccessException 계층구조
    1. DAO 인터페이스와 구현의 분리
    2. 데이터 액세스 예외 추상화와 DataAccessException 계층구조
4. 기술에 독립적인 UserDao 만들기
    1. 인터페이스 적용
    2. 테스트 보완
    3. DataAccessException 활용 시 주의사항

### 정리

- 예외를 잡아서 아무런 조취를 취하지 않거나 의미 없는 throws 선언을 남발하는 것은 위험하다.
- 예외는 복구하거나 예외처리 오브젝트로 의도적으로 전달하거나 적절한 예외로 전환해야 한다.
- 좀 더 의미 있는 예외로 변경하거나, 불필요한 catch/throws 를 피하기 위해 런타임 예외로 포장하는 두 가지 방법의 예외 전환이 있다.
- 복구할 수 없는 예외는 가능한 한 빨리 런타임 예외로 전환하는 것이 바람직하다.
- 애플리케이션의 로직을 담기 위한 예외는 체크 예외로 만든다.
- JDBC의 SQLExcepetion은 대부분 복구할 수 없는 예외이므로 런타임 예외로 포장해야 한다.
- SQLException의 에러 코드는 DB에 정속되기 때문에 DB에 독립적인 예외로 전환될 필요가 있다.
- 스프링은 DataAccessException을 통해 DB에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공한다.
- DAO를 데이터 액세스 기술에서 독립시키려면 인터페이스 도입과 런타임 예외 전환, 기술에 독립적인 추상화된 예외로 전환이 필요하다.